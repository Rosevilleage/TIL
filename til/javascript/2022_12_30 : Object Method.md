## 객체의 메서드들 
 
 #### 정적 매서드
  
 1. `Object.assign()` : 하나 이상의 원본 객체들로부터 모든 열거 가능한 속성들을 대상 객체로 복사
    * 두 개의 객체를 받아 한 객체에 다른 객체를 복사
 2. `Object.create()` : 지정한 프로토타입의 객체 및 속성을 가지고 있는 새 객체를 생성
 3. `Object.defineProperty()` : 지정한 서술자(descriptor)에서 서술한 속성을 객체에 추가
    * defineProperty로 추가된 속성은 기본적으로 불변하고, 열거 불가능
    * (서술자(descriptor)도 공부해서 추후에 정리)
 4. `Object.defineProperties()` : 지정한 서술자들에게서 서술한 속성들을 객체에 추가
 5. `Object.entries()` : 지정한 객체 자신의 모든 열거 가능한 문자열 속성을 [key, value] 쌍으로 구성된 배열을 반환 
    * 반환한 배열의 순서는 객체가 정의된 순서와는 상관없고, for-in과 같은 순서로 작동하지만 for-in과 다르게 프로토타입 체인의 속성을 열거하지 못한다.
 6. `Object.freeze()` : 객체를 고정, 다른 곳에서 해당 속성을 삭제, 변경 불가능
 7. `Object.fromEntries()` : [key, value] 쌍의 iterable로 부터 새 객체를 반환(entries의 반대)
 8. `Object.is()` : 두 값이 같은지 확인
    * 모든 NaN값을 같다고 처리
 9. `Object.isExtensible()` : 객체의 확장 가능 여부 확인
 10. `Object.isFrozen()` : 객체의 고정 여부 확인
 11. `Object.isSealed()` : 객체의 봉인 여부 확인
 12. `Object.keys()` : 지정한 객체 자신의 모든 열거 가능한 문자열 속성들의 이름으로 구성된 배열을 반환
 13. `Object.prevenExtensions()` : 객체가 확장되지 못하게 함
 14. `Object.seal()` : 다른 코드가 객체의 속성을 삭제하지 못하게 밀봉 함 
    * 밀봉된 객체는 새로운 속성을 추가할 수 없고, 현존하는 모든 속성을 설정 불가능 상태로 만든다. 하지만 쓰기 가능한 속성의 값은 밀봉 후에도 변경 가능 즉 속성 값의 변경은 가능
    * 프로토타입 체인은 밀봉 전이나 후가 달라지진 않지만, `.__proto__` 속성은 함께 밀봉
    * freeze은 쓰기가능 속성 포함 전부 불가능
 15. `Object.values()` : 지정한 객체 자신의 모든 열거 가능한 문자열 속성에 해당하는 값들로 구성된 배열을 반환
   
> 오늘 수업을 진행하면서 내가 객체에 대해서 생각보다 약하다는 것을 알았다. 앞으로 객체를 이용하는 경험이 자주 있었으면 좋겠다. 오늘은 객체의 정적 메서드를 정리한다. 사용해본적 없고 잘 모르는 정적 메서드와 인스턴스 메서드들은 조금 공부를 하고 난 뒤에 추가하겠다.   